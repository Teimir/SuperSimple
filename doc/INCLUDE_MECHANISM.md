# Как работают .h файлы в нашем языке

## Обзор

В нашем языке `.h` файлы (и любые другие файлы) работают через механизм **препроцессора** (`#include` директивы). Препроцессор обрабатывает исходный код **до** лексического анализа и парсинга, вставляя содержимое включенных файлов напрямую в исходный код.

## Процесс обработки

### 1. Порядок выполнения

```
Исходный файл (.sc)
    ↓
Препроцессор (#include обработка)
    ↓
Объединенный код
    ↓
Лексер (токенизация)
    ↓
Парсер (AST)
    ↓
Интерпретатор (выполнение)
```

### 2. Синтаксис #include

Поддерживаются два формата:

```c
#include "filename.h"    // Относительный путь (в кавычках)
#include <filename.h>    // Относительный путь (в угловых скобках)
```

**Важно:** В текущей реализации оба формата работают одинаково - ищут файл относительно текущего файла или базовой директории.

### 3. Алгоритм поиска файлов

Препроцессор ищет файлы в следующем порядке:

1. **Абсолютный путь** - если указан полный путь, используется он
2. **Относительно текущего файла** - сначала ищет в директории, где находится файл с `#include`
3. **Относительно базовой директории** - затем ищет в директории основного файла
4. **Текущая рабочая директория** - в конце проверяет текущую директорию

### 4. Рекурсивная обработка

Препроцессор обрабатывает вложенные `#include` рекурсивно:

```c
// main.sc
#include "utils.sc"    // Включает utils.sc
#include "math_ops.sc" // Включает math_ops.sc

function main() {
    return add(1, 2);  // Использует функцию из utils.sc
}
```

```c
// utils.sc
function add(a, b) {
    return a + b;
}
```

**Результат препроцессинга:**
```c
// Included from: utils.sc
function add(a, b) {
    return a + b;
}
// End include: utils.sc

// Included from: math_ops.sc
// ... содержимое math_ops.sc ...
// End include: math_ops.sc

function main() {
    return add(1, 2);
}
```

### 5. Защита от циклических включений

Препроцессор отслеживает уже включенные файлы и предотвращает циклические включения:

```c
// circular_a.sc
#include "circular_b.sc"  // ❌ Ошибка: циклическое включение
function func_a() {
    return 1;
}
```

```c
// circular_b.sc
#include "circular_a.sc"  // ❌ Ошибка: циклическое включение
function func_b() {
    return 2;
}
```

**Результат:** `PreprocessingError: Circular include detected`

## Примеры использования

### Пример 1: Простое включение

**hardware.h:**
```c
// Константы для работы с железом
// GPIO_INPUT = 0
// GPIO_OUTPUT = 1
```

**main.sc:**
```c
#include "hardware.h"

function main() {
    // Теперь можно использовать константы (если бы был #define)
    return 0;
}
```

### Пример 2: Включение функций

**utils.sc:**
```c
function add(a, b) {
    return a + b;
}

function multiply(a, b) {
    return a * b;
}
```

**main.sc:**
```c
#include "utils.sc"

function main() {
    uint32 x = add(5, 3);      // 8
    uint32 y = multiply(2, 4); // 8
    return x + y;              // 16
}
```

### Пример 3: Вложенные включения

**base.sc:**
```c
function base() {
    return 1;
}
```

**middle.sc:**
```c
#include "base.sc"

function middle() {
    return base() + 1;  // Использует функцию из base.sc
}
```

**main.sc:**
```c
#include "middle.sc"

function main() {
    return middle();  // Вернет 2
}
```

**Результат препроцессинга main.sc:**
```c
// Included from: middle.sc
// Included from: base.sc
function base() {
    return 1;
}
// End include: base.sc

function middle() {
    return base() + 1;
}
// End include: middle.sc

function main() {
    return middle();
}
```

## Важные особенности

### 1. Нет поддержки #define

⚠️ **Важно:** В текущей реализации препроцессор **НЕ** обрабатывает `#define` директивы. Файлы с `#define` (например, `hardware.h`) будут включены, но макросы не будут раскрыты.

**Решение:** Используйте комментарии для документации констант или определяйте их как переменные/функции.

### 2. Имя файла не важно

Расширение `.h` или `.sc` не имеет значения - препроцессор просто вставляет содержимое файла. Можно использовать:
- `#include "utils.sc"`
- `#include "hardware.h"`
- `#include "constants.txt"` (если это валидный код)

### 3. Область видимости

Все включенные функции и переменные становятся частью глобальной области видимости. Порядок включения важен, если функции зависят друг от друга.

### 4. Комментарии включений

Препроцессор автоматически добавляет комментарии для отладки:
```c
// Included from: filename.h
// ... содержимое файла ...
// End include: filename.h
```

## Практические рекомендации

### ✅ Хорошие практики

1. **Используйте .h для заголовков** - константы, объявления функций
2. **Используйте .sc для библиотек** - реализации функций
3. **Организуйте по функциональности** - `gpio.h`, `uart.h`, `timer.h`
4. **Документируйте зависимости** - указывайте, какие файлы нужны

### ❌ Избегайте

1. Циклических включений
2. Слишком глубокой вложенности (сложно отлаживать)
3. Включения больших файлов в циклы (неэффективно)

## Реализация в коде

Препроцессор реализован в `preprocessor.py`:

```python
from preprocessor import Preprocessor

# Создание препроцессора
preprocessor = Preprocessor()

# Обработка файла
source_code = preprocessor.preprocess("main.sc")

# source_code теперь содержит весь объединенный код
```

В `main.py` препроцессор вызывается перед лексированием:

```python
# 1. Препроцессинг
preprocessor = Preprocessor()
source_code = preprocessor.preprocess(source_file)

# 2. Лексирование
lexer = Lexer(source_code)
tokens = lexer.tokenize()

# 3. Парсинг
parser = Parser(tokens)
ast = parser.parse()

# 4. Интерпретация
interpreter = Interpreter(ast)
result = interpreter.run()
```

## Примеры в проекте

- `test_examples/includes/utils.sc` - библиотека утилит
- `test_examples/includes/math_ops.sc` - математические операции
- `test_examples/includes/nested_include.sc` - пример вложенных включений
- `test_examples/hardware/hardware.h` - константы для железа
- `test_examples/hardware/gpio.h` - GPIO константы

## Заключение

`.h` файлы в нашем языке работают как простые текстовые включения - их содержимое вставляется в исходный код до компиляции. Это позволяет:
- Организовывать код в модули
- Переиспользовать функции и константы
- Создавать библиотеки
- Упрощать поддержку больших проектов
