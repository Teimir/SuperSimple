\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
\usepackage[T2A]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{longtable}
\usepackage{booktabs}

\geometry{margin=2.5cm}

% Code listing style
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=2,
    captionpos=b,
    escapeinside={\%*}{*)}
}

% Define custom colors
\definecolor{codebg}{RGB}{245,245,245}
\lstset{backgroundcolor=\color{codebg}}

\title{Simple C-Style Language\\Документация проекта}
\author{}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Введение}

\subsection{О проекте}

Simple C-Style Language --- это минималистичный образовательный язык программирования в стиле C с поддержкой:
\begin{itemize}
    \item 32-битных беззнаковых целых чисел как единственного типа данных
    \item Функций с параметрами и возвращаемыми значениями
    \item Циклов \texttt{for} и \texttt{while}
    \item Условных операторов (\texttt{if/else})
    \item Арифметических и логических операций
\end{itemize}

\subsection{Требования}

\begin{itemize}
    \item Python 3.7 или выше
    \item Дополнительные зависимости не требуются
\end{itemize}

\subsection{Использование}

Запуск программы:
\begin{lstlisting}[language=bash]
python main.py <source_file>
\end{lstlisting}

Программа выполнится и выведет возвращаемое значение функции \texttt{main}.

Пример:
\begin{lstlisting}[language=bash]
python main.py examples/factorial.sc
\end{lstlisting}

\subsection{Компиляция}

Компиляция исходного файла в FASM ассемблер, затем в бинарный файл:
\begin{lstlisting}[language=bash]
python compile.py <source_file> [output_file] [--run]
\end{lstlisting}

Опции:
\begin{itemize}
    \item \texttt{output\_file} --- опциональный путь к выходному файлу \texttt{.asm} (по умолчанию: \texttt{<source\_file>.asm})
    \item \texttt{--run} --- после компиляции запустить бинарный файл с помощью \texttt{interpreter\_x64.exe} из \texttt{int\_pack}
\end{itemize}

Примеры:
\begin{lstlisting}[language=bash]
# Компиляция в ассемблер и бинарный файл
python compile.py examples/basic/sum_range.sc

# Компиляция и запуск
python compile.py examples/basic/sum_range.sc --run
\end{lstlisting}

Это генерирует:
\begin{itemize}
    \item \texttt{.asm} файл --- исходный код FASM ассемблера
    \item \texttt{.bin} файл --- бинарный исполняемый файл (скомпилированный с \texttt{int\_pack/FASM.EXE})
    \item \texttt{.mif} файл --- файл инициализации памяти для Quartus
\end{itemize}

\newpage

\section{Спецификация языка}

\subsection{Обзор}

Это простой язык программирования в стиле C с минимальным набором функций. Язык разработан для образовательных целей и фокусируется на основных концепциях программирования с ограниченной системой типов.

\subsection{Основные возможности}

\begin{itemize}
    \item \textbf{Единственный тип данных}: только 32-битные беззнаковые целые числа (\texttt{uint32})
    \item \textbf{Функции}: пользовательские функции с параметрами и возвращаемыми значениями
    \item \textbf{Управление потоком}: циклы \texttt{for} и \texttt{while}
    \item \textbf{Выражения}: арифметические, логические и побитовые операции
    \item \textbf{Операторы}: объявления переменных, присваивания, вызовы функций и управление потоком
    \item \textbf{Включение файлов}: директива \texttt{\#include} для модульной организации кода
    \item \textbf{Поддержка железа}: доступ к регистрам, GPIO, UART, операции таймера
    \item \textbf{Прерывания}: обработчики прерываний (ISR)
    \item \textbf{Побитовые операции}: встроенные функции для побитовых операций
\end{itemize}

\subsection{Типы данных}

\subsubsection{Беззнаковое 32-битное целое число (uint32)}

Единственный тип данных в языке. Все переменные, параметры функций и возвращаемые значения неявно являются \texttt{uint32}.

\begin{itemize}
    \item Диапазон: от 0 до 4,294,967,295 ($2^{32} - 1$)
    \item Поведение при переполнении: зацикливается (по модулю $2^{32}$)
\end{itemize}

\subsection{Лексические элементы}

\subsubsection{Идентификаторы}

\begin{itemize}
    \item Должны начинаться с буквы или подчёркивания
    \item Могут содержать буквы, цифры и подчёркивания
    \item Регистрозависимые
    \item Примеры: \texttt{x}, \texttt{myVar}, \texttt{\_count}, \texttt{counter123}
\end{itemize}

\subsubsection{Литералы}

\begin{itemize}
    \item \textbf{Десятичные литералы}: последовательности цифр (0-9)
    \begin{itemize}
        \item Примеры: \texttt{0}, \texttt{42}, \texttt{1000}, \texttt{4294967295}
    \end{itemize}
    \item \textbf{Шестнадцатеричные литералы}: с префиксом \texttt{0x} или \texttt{0X}, за которым следуют шестнадцатеричные цифры (0-9, A-F, a-f)
    \begin{itemize}
        \item Примеры: \texttt{0x0}, \texttt{0xFF}, \texttt{0x10}, \texttt{0X1A2B}, \texttt{0xABCDEF}
        \item Поддерживаются как заглавные, так и строчные буквы A-F
        \item Допускается смешанный регистр: \texttt{0xAa}, \texttt{0XbB}
    \end{itemize}
\end{itemize}

\subsubsection{Ключевые слова}

\begin{lstlisting}
uint32    (ключевое слово типа, хотя все типы uint32)
function  (объявление функции)
for       (цикл for)
while     (цикл while)
if        (условный оператор)
else      (блок else)
return    (оператор возврата)
register  (класс хранения регистр)
volatile  (квалификатор volatile)
interrupt (квалификатор функции прерывания)
\end{lstlisting}

\subsubsection{Операторы}

\textbf{Арифметические:}
\begin{itemize}
    \item \texttt{+} (сложение)
    \item \texttt{-} (вычитание)
    \item \texttt{*} (умножение)
    \item \texttt{/} (целочисленное деление)
    \item \texttt{\%} (модуло)
\end{itemize}

\textbf{Отношения:}
\begin{itemize}
    \item \texttt{==} (равенство)
    \item \texttt{!=} (неравенство)
    \item \texttt{<} (меньше)
    \item \texttt{<=} (меньше или равно)
    \item \texttt{>} (больше)
    \item \texttt{>=} (больше или равно)
\end{itemize}

\textbf{Логические:}
\begin{itemize}
    \item \texttt{\&\&} (логическое И)
    \item \texttt{||} (логическое ИЛИ)
    \item \texttt{!} (логическое НЕ)
\end{itemize}

\textbf{Побитовые:}
\begin{itemize}
    \item \texttt{\&} (побитовое И)
    \item \texttt{|} (побитовое ИЛИ)
    \item \texttt{\textasciicircum} (побитовое исключающее ИЛИ)
    \item \texttt{\textasciitilde} (побитовое НЕ)
    \item \texttt{<<} (сдвиг влево)
    \item \texttt{>>} (сдвиг вправо)
\end{itemize}

\textbf{Присваивание:}
\begin{itemize}
    \item \texttt{=} (присваивание)
    \item \texttt{++} (инкремент)
    \item \texttt{--} (декремент)
\end{itemize}

\subsection{Синтаксис}

\subsubsection{Структура программы}

Программа состоит из серии определений функций. Точка входа --- функция \texttt{main}, которая не принимает параметры.

\begin{lstlisting}
function main() {
    // код программы
}
\end{lstlisting}

\subsubsection{Объявление переменной}

Переменные должны быть объявлены с ключевым словом \texttt{uint32} перед использованием.

\begin{lstlisting}
uint32 x;
uint32 y = 42;
uint32 z = x + y;
\end{lstlisting}

\subsubsection{Присваивание}

Переменные присваиваются с помощью оператора \texttt{=}.

\begin{lstlisting}
x = 10;
x = x + 1;
x = y * 2;
\end{lstlisting}

\subsubsection{Инкремент и декремент}

Переменные могут быть увеличены или уменьшены с помощью операторов \texttt{++} и \texttt{--}. Поддерживаются как префиксная, так и постфиксная формы.

\begin{lstlisting}
uint32 x = 5;
++x;    // префиксный инкремент: x становится 6
x++;    // постфиксный инкремент: x становится 7
--x;    // префиксный декремент: x становится 6
x--;    // постфиксный декремент: x становится 5
\end{lstlisting}

Операторы инкремента и декремента также могут использоваться в приращениях цикла \texttt{for}:
\begin{lstlisting}
for (uint32 i = 0; i < 10; i++) {
    // тело цикла
}

for (uint32 i = 10; i > 0; i--) {
    // тело цикла
}
\end{lstlisting}

\subsubsection{Выражения}

Выражения комбинируют литералы, переменные и операторы. Приоритет операторов следует стандартным правилам C:
\begin{enumerate}
    \item Скобки
    \item Унарные операторы (\texttt{!}, \texttt{-})
    \item Мультипликативные (\texttt{*}, \texttt{/}, \texttt{\%})
    \item Аддитивные (\texttt{+}, \texttt{-})
    \item Отношения (\texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=})
    \item Равенство (\texttt{==}, \texttt{!=})
    \item Логическое И (\texttt{\&\&})
    \item Логическое ИЛИ (\texttt{||})
\end{enumerate}

\subsubsection{Функции}

Функции объявляются с ключевым словом \texttt{function}, за которым следует имя функции, параметры и тело.

\begin{lstlisting}
function functionName(param1, param2, ...) {
    // тело функции
    return value;
}
\end{lstlisting}

\begin{itemize}
    \item Имена функций следуют правилам идентификаторов
    \item Параметры неявно являются \texttt{uint32} (не включайте ключевое слово \texttt{uint32} в список параметров)
    \item Функции могут возвращать значение с помощью \texttt{return}
    \item Если оператор \texttt{return} не выполняется, функция возвращает 0
    \item Функции могут вызываться до их определения (поддержка предварительных объявлений)
\end{itemize}

\subsubsection{Условные операторы}

\begin{lstlisting}
if (condition) {
    // операторы
}

if (condition) {
    // операторы
} else {
    // операторы
}
\end{lstlisting}

\subsubsection{Цикл while}

\begin{lstlisting}
while (condition) {
    // операторы
}
\end{lstlisting}

\subsubsection{Цикл for}

Цикл \texttt{for} следует синтаксису в стиле C:
\begin{lstlisting}
for (initialization; condition; increment) {
    // операторы
}
\end{lstlisting}

\begin{itemize}
    \item \texttt{initialization}: выполняется один раз перед циклом (обычно присваивание переменной)
    \item \texttt{condition}: вычисляется перед каждой итерацией
    \item \texttt{increment}: выполняется после каждой итерации (обычно обновление переменной)
\end{itemize}

Пример:
\begin{lstlisting}
for (uint32 i = 0; i < 10; i = i + 1) {
    // тело цикла
}
\end{lstlisting}

\subsection{Грамматика (BNF-like)}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
program        := function_def*
function_def   := 'function' IDENTIFIER '(' param_list? ')' '{' statement* '}'
param_list     := IDENTIFIER (',' IDENTIFIER)*

statement      := var_decl ';'
                | assignment ';'
                | function_call ';'
                | return_stmt ';'
                | if_stmt
                | while_stmt
                | for_stmt
                | block

var_decl       := 'uint32' IDENTIFIER ('=' expression)?
assignment     := IDENTIFIER '=' expression
function_call  := IDENTIFIER '(' expr_list? ')'
return_stmt    := 'return' expression?

if_stmt        := 'if' '(' expression ')' statement ('else' statement)?
while_stmt     := 'while' '(' expression ')' statement
for_stmt       := 'for' '(' (var_decl | assignment)? ';' expression? ';' assignment? ')' statement

block          := '{' statement* '}'
expr_list      := expression (',' expression)*

expression     := logical_or
logical_or     := logical_and ('||' logical_and)*
logical_and    := equality ('&&' equality)*
equality       := relational (('==' | '!=') relational)*
relational     := additive (('<' | '<=' | '>' | '>=') additive)*
additive       := multiplicative (('+' | '-') multiplicative)*
multiplicative := unary (('*' | '/' | '%') unary)*
unary          := ('!' | '-') unary | primary
primary        := IDENTIFIER
                | LITERAL
                | '(' expression ')'
                | function_call
\end{lstlisting}

\subsection{Возможности железа}

Язык включает встроенную поддержку периферийных устройств MCU.

\subsubsection{Доступ к регистрам}

CPU регистры (r0-r31) могут быть доступны напрямую:
\begin{lstlisting}
register uint32 r0 = 10;
register uint32 r1 = 20;
register uint32 r2 = r0 + r1;  // r2 = 30
\end{lstlisting}

\begin{itemize}
    \item Регистровые переменные должны быть названы \texttt{r0} через \texttt{r31}
    \item Регистр r31 (указатель инструкций) только для чтения
    \item Регистры неявно volatile
\end{itemize}

\subsubsection{Операции GPIO}

Управление GPIO пинами для цифрового ввода/вывода:
\begin{lstlisting}
// Настройка пина 0 как выход
gpio_set(0, GPIO_OUTPUT, GPIO_NONE);

// Запись в GPIO
gpio_write(0, GPIO_HIGH);

// Чтение из GPIO
uint32 value = gpio_read(0);
\end{lstlisting}

\textbf{Функции:}
\begin{itemize}
    \item \texttt{gpio\_set(pin, direction, mode)} --- настройка GPIO пина
    \item \texttt{gpio\_read(pin)} --- чтение значения GPIO пина
    \item \texttt{gpio\_write(pin, value)} --- запись значения GPIO пина
\end{itemize}

\subsubsection{Операции UART}

Последовательная связь через UART:
\begin{lstlisting}
// Установка скорости передачи
uart_set_baud(115200);

// Проверка статуса
uint32 status = uart_get_status();

// Чтение из UART
uint32 data = uart_read();

// Запись в UART
uart_write(data);
\end{lstlisting}

\textbf{Функции:}
\begin{itemize}
    \item \texttt{uart\_set\_baud(baud\_rate)} --- установка скорости UART
    \item \texttt{uart\_get\_status()} --- получение статуса UART
    \item \texttt{uart\_read()} --- чтение байта из UART
    \item \texttt{uart\_write(data)} --- запись байта в UART
\end{itemize}

\subsubsection{Операции таймера}

Управление аппаратным таймером:
\begin{lstlisting}
// Настройка таймера
timer_set_mode(TIMER_PERIODIC);
timer_set_period(1000000);  // 1 секунда в микросекундах
timer_start();

// Проверка истечения
if (timer_expired()) {
    timer_reset();
}
\end{lstlisting}

\textbf{Функции:}
\begin{itemize}
    \item \texttt{timer\_set\_mode(mode)} --- установка режима таймера (ONESHOT, PERIODIC, CONTINUOUS)
    \item \texttt{timer\_set\_period(microseconds)} --- установка периода таймера
    \item \texttt{timer\_start()} --- запуск таймера
    \item \texttt{timer\_stop()} --- остановка таймера
    \item \texttt{timer\_reset()} --- сброс счётчика таймера
    \item \texttt{timer\_get\_value()} --- получение текущего значения таймера
    \item \texttt{timer\_expired()} --- проверка истечения таймера
\end{itemize}

\subsubsection{Обработчики прерываний}

Обработка аппаратных прерываний:
\begin{lstlisting}
volatile uint32 counter = 0;

interrupt function timer_isr() {
    counter++;
    timer_reset();
}

function main() {
    timer_set_mode(TIMER_PERIODIC);
    timer_set_period(1000000);
    timer_start();
    enable_interrupts();
    
    while (counter < 10) {
        // Основной цикл
    }
    
    disable_interrupts();
    return counter;
}
\end{lstlisting}

\subsubsection{Побитовые операции}

Встроенные функции для побитовых операций:
\begin{lstlisting}
uint32 value = 0;

value = set_bit(value, 5);      // Установить бит 5
value = clear_bit(value, 5);    // Сбросить бит 5
value = toggle_bit(value, 3);   // Переключить бит 3
uint32 bit = get_bit(value, 5);  // Получить значение бита 5

// Шестнадцатеричные литералы часто используются для битовых масок
uint32 mask = 0xFF;              // 8 бит установлено
uint32 flags = 0x0F;             // Нижние 4 бита
uint32 result = value & mask;    // Применить маску используя шестнадцатеричный литерал
\end{lstlisting}

\textbf{Функции:}
\begin{itemize}
    \item \texttt{set\_bit(value, bit)} --- установить бит
    \item \texttt{clear\_bit(value, bit)} --- сбросить бит
    \item \texttt{toggle\_bit(value, bit)} --- переключить бит
    \item \texttt{get\_bit(value, bit)} --- получить значение бита (0 или 1)
\end{itemize}

\subsubsection{Функции задержки}

Программные задержки:
\begin{lstlisting}
delay_ms(100);      // Задержка 100 миллисекунд
delay_us(1000);     // Задержка 1000 микросекунд
delay_cycles(1000); // Задержка N циклов CPU
\end{lstlisting}

\subsection{Примеры}

\subsubsection{Пример 1: Простая программа}

\begin{lstlisting}
function main() {
    uint32 x = 10;
    uint32 y = 20;
    uint32 sum = x + y;
    return sum;
}
\end{lstlisting}

\subsubsection{Пример 2: Функция факториала}

\begin{lstlisting}
function factorial(n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    uint32 result = 1;
    uint32 i = 2;
    while (i <= n) {
        result = result * i;
        i = i + 1;
    }
    return result;
}

function main() {
    uint32 n = 5;
    uint32 fact = factorial(n);
    return fact;  // возвращает 120
}
\end{lstlisting}

\subsubsection{Пример 3: Пример с циклом for}

\begin{lstlisting}
function sum_range(start, end) {
    uint32 sum = 0;
    uint32 i;
    for (i = start; i <= end; i = i + 1) {
        sum = sum + i;
    }
    return sum;
}

function main() {
    uint32 result = sum_range(1, 10);
    return result;  // возвращает 55
}
\end{lstlisting}

\newpage

\section{Архитектура системы}

\subsection{Обзор}

Этот документ описывает архитектуру и дизайн интерпретатора Simple C-Style Language.

\subsection{Пайплайн компиляции}

Язык следует традиционному пайплайну компилятора/интерпретатора:

\begin{lstlisting}[basicstyle=\ttfamily\small]
Исходный файл (.sc)
    ↓
[Препроцессор]  # Обработка директив #include
    ↓
Исходный код (с расширенными включениями)
    ↓
[Лексер]         # Токенизация
    ↓
Поток токенов
    ↓
[Парсер]         # Синтаксический анализ
    ↓
Абстрактное синтаксическое дерево (AST)
    ↓
[Интерпретатор]  # Выполнение
    ↓
Результат программы
\end{lstlisting}

\subsection{Детали компонентов}

\subsubsection{1. Препроцессор (\texttt{preprocessor.py})}

\textbf{Назначение}: Обрабатывает директивы \texttt{\#include} до лексирования.

\textbf{Основные возможности}:
\begin{itemize}
    \item Рекурсивное включение файлов
    \item Обнаружение циклических зависимостей
    \item Разрешение путей (относительных и абсолютных)
    \item Вставка комментариев для отладки
\end{itemize}

\textbf{Классы}:
\begin{itemize}
    \item \texttt{Preprocessor} --- основной класс препроцессинга
    \item \texttt{PreprocessingError} --- исключение для ошибок препроцессинга
\end{itemize}

\subsubsection{2. Лексер (\texttt{lexer.py})}

\textbf{Назначение}: Преобразует исходный код в поток токенов.

\textbf{Основные возможности}:
\begin{itemize}
    \item Распознавание токенов для всех элементов языка
    \item Отслеживание строк и столбцов для отчётов об ошибках
    \item Обработка комментариев (однострочных и многострочных)
    \item Обработка пробелов
\end{itemize}

\textbf{Классы}:
\begin{itemize}
    \item \texttt{TokenType} --- перечисление всех типов токенов
    \item \texttt{Token} --- токен с типом, значением, строкой и столбцом
    \item \texttt{Lexer} --- основной класс лексера
\end{itemize}

\subsubsection{3. Парсер (\texttt{parser.py})}

\textbf{Назначение}: Строит абстрактное синтаксическое дерево (AST) из токенов.

\textbf{Основные возможности}:
\begin{itemize}
    \item Рекурсивный нисходящий парсинг
    \item Обработка приоритета операторов
    \item Парсинг выражений с правильной ассоциативностью
    \item Парсинг операторов (объявления, присваивания, управление потоком)
\end{itemize}

\textbf{Типы узлов AST}:
\begin{itemize}
    \item \texttt{Program} --- корневой узел, содержащий все функции
    \item \texttt{FunctionDef} --- определение функции
    \item \texttt{VarDecl} --- объявление переменной
    \item \texttt{Assignment} --- присваивание переменной
    \item \texttt{IfStmt} --- оператор if/else
    \item \texttt{WhileStmt} --- цикл while
    \item \texttt{ForStmt} --- цикл for
    \item \texttt{ReturnStmt} --- оператор return
    \item \texttt{Block} --- блок кода
    \item \texttt{BinaryOp} --- бинарная операция
    \item \texttt{UnaryOp} --- унарная операция
    \item \texttt{FunctionCall} --- вызов функции
    \item \texttt{Identifier} --- ссылка на переменную
    \item \texttt{Literal} --- целочисленный литерал
\end{itemize}

\subsubsection{4. Интерпретатор (\texttt{interpreter.py})}

\textbf{Назначение}: Выполняет AST и управляет состоянием времени выполнения.

\textbf{Основные возможности}:
\begin{itemize}
    \item Управление окружением (область видимости переменных)
    \item Обработка вызовов функций
    \item Выполнение управления потоком
    \item Встроенные аппаратные функции
    \item Симуляция регистров
    \item Обработка прерываний
\end{itemize}

\textbf{Классы}:
\begin{itemize}
    \item \texttt{Environment} --- управление областью видимости переменных
    \item \texttt{Interpreter} --- основной класс интерпретатора
    \item \texttt{RuntimeError} --- исключение времени выполнения
\end{itemize}

\textbf{Состояние времени выполнения}:
\begin{itemize}
    \item \texttt{global\_env} --- окружение глобальных переменных
    \item \texttt{functions} --- определения функций
    \item \texttt{registers} --- симуляция CPU регистров (32 регистра)
    \item \texttt{register\_map} --- отображение имён регистров на индексы
    \item \texttt{interrupt\_handlers} --- подпрограммы обработки прерываний
    \item Состояние железа (GPIO, UART, Timer)
\end{itemize}

\subsection{Поток данных}

\subsubsection{Объявление переменной}

\begin{lstlisting}[basicstyle=\ttfamily\small]
VarDecl AST узел
    ↓
execute_var_decl()
    ↓
Environment.declare()
    ↓
Переменная сохранена в окружении
\end{lstlisting}

\subsubsection{Вызов функции}

\begin{lstlisting}[basicstyle=\ttfamily\small]
FunctionCall AST узел
    ↓
evaluate_expression()
    ↓
execute_function()
    ↓
Создание нового окружения для параметров
    ↓
Выполнение тела функции
    ↓
Возвращаемое значение
\end{lstlisting}

\subsection{Модель памяти}

\subsubsection{Хранение переменных}
\begin{itemize}
    \item Переменные хранятся в объектах \texttt{Environment}
    \item Каждая область видимости имеет своё окружение
    \item Окружения образуют цепочку (отношение родитель-потомок)
    \item Глобальные переменные находятся в \texttt{global\_env}
\end{itemize}

\subsubsection{Хранение регистров}
\begin{itemize}
    \item CPU регистры (r0-r31) хранятся в массиве \texttt{interpreter.registers}
    \item Доступ к регистровым переменным осуществляется через \texttt{register\_map}
    \item Доступ к регистрам обходит обычный поиск переменных
\end{itemize}

\newpage

\section{Механизм включения файлов}

\subsection{Обзор}

В нашем языке файлы \texttt{.h} (и любые другие файлы) работают через механизм \textbf{препроцессора} (директивы \texttt{\#include}). Препроцессор обрабатывает исходный код \textbf{до} лексического анализа и парсинга, вставляя содержимое включённых файлов напрямую в исходный код.

\subsection{Процесс обработки}

\subsubsection{1. Порядок выполнения}

\begin{lstlisting}[basicstyle=\ttfamily\small]
Исходный файл (.sc)
    ↓
Препроцессор (#include обработка)
    ↓
Объединённый код
    ↓
Лексер (токенизация)
    ↓
Парсер (AST)
    ↓
Интерпретатор (выполнение)
\end{lstlisting}

\subsubsection{2. Синтаксис \#include}

Поддерживаются два формата:
\begin{lstlisting}
#include "filename.h"    // Относительный путь (в кавычках)
#include <filename.h>    // Относительный путь (в угловых скобках)
\end{lstlisting}

\textbf{Важно}: В текущей реализации оба формата работают одинаково --- ищут файл относительно текущего файла или базовой директории.

\subsubsection{3. Алгоритм поиска файлов}

Препроцессор ищет файлы в следующем порядке:
\begin{enumerate}
    \item \textbf{Абсолютный путь} --- если указан полный путь, используется он
    \item \textbf{Относительно текущего файла} --- сначала ищет в директории, где находится файл с \texttt{\#include}
    \item \textbf{Относительно базовой директории} --- затем ищет в директории основного файла
    \item \textbf{Текущая рабочая директория} --- в конце проверяет текущую директорию
\end{enumerate}

\subsubsection{4. Рекурсивная обработка}

Препроцессор обрабатывает вложенные \texttt{\#include} рекурсивно:

\textbf{main.sc:}
\begin{lstlisting}
#include "utils.sc"    // Включает utils.sc
#include "math_ops.sc" // Включает math_ops.sc

function main() {
    return add(1, 2);  // Использует функцию из utils.sc
}
\end{lstlisting}

\textbf{utils.sc:}
\begin{lstlisting}
function add(a, b) {
    return a + b;
}
\end{lstlisting}

\textbf{Результат препроцессинга:}
\begin{lstlisting}
// Included from: utils.sc
function add(a, b) {
    return a + b;
}
// End include: utils.sc

// Included from: math_ops.sc
// ... содержимое math_ops.sc ...
// End include: math_ops.sc

function main() {
    return add(1, 2);
}
\end{lstlisting}

\subsubsection{5. Защита от циклических включений}

Препроцессор отслеживает уже включённые файлы и предотвращает циклические включения:

\textbf{circular\_a.sc:}
\begin{lstlisting}
#include "circular_b.sc"  // ❌ Ошибка: циклическое включение
function func_a() {
    return 1;
}
\end{lstlisting}

\textbf{circular\_b.sc:}
\begin{lstlisting}
#include "circular_a.sc"  // ❌ Ошибка: циклическое включение
function func_b() {
    return 2;
}
\end{lstlisting}

\textbf{Результат}: \texttt{PreprocessingError: Circular include detected}

\subsection{Важные особенности}

\subsubsection{1. Нет поддержки \#define}

⚠️ \textbf{Важно}: В текущей реализации препроцессор \textbf{НЕ} обрабатывает директивы \texttt{\#define}. Файлы с \texttt{\#define} (например, \texttt{hardware.h}) будут включены, но макросы не будут раскрыты.

\textbf{Решение}: Используйте комментарии для документации констант или определяйте их как переменные/функции.

\subsubsection{2. Имя файла не важно}

Расширение \texttt{.h} или \texttt{.sc} не имеет значения --- препроцессор просто вставляет содержимое файла. Можно использовать:
\begin{itemize}
    \item \texttt{\#include "utils.sc"}
    \item \texttt{\#include "hardware.h"}
    \item \texttt{\#include "constants.txt"} (если это валидный код)
\end{itemize}

\newpage

\section{Генерация кода}

\subsection{Обзор}

Генератор кода (\texttt{codegen.py}) переводит AST (абстрактное синтаксическое дерево) в код FASM ассемблера, нацеленный на ISA, описанную в \texttt{isa/README.md}.

\subsection{Архитектура}

\subsubsection{Распределение регистров}

Генератор кода использует простую стратегию фиксированного распределения регистров:
\begin{itemize}
    \item \textbf{r0-r10}: Временные регистры (для вычисления выражений)
    \item \textbf{r11-r25}: Локальные переменные
    \item \textbf{r26-r30}: Параметры функций
    \item \textbf{r31}: Указатель инструкций (только для чтения в пользовательском коде, управляется железом)
\end{itemize}

\subsubsection{Соглашение о вызовах функций}

\begin{itemize}
    \item Параметры передаются в r26-r30 (до 5 параметров)
    \item Возвращаемое значение в r0
    \item Регистр связи: r30 (для адреса возврата, в правильной реализации)
\end{itemize}

\subsubsection{Пайплайн генерации кода}

\begin{lstlisting}[basicstyle=\ttfamily\small]
AST
  ↓
CodeGenerator.generate()
  ↓
RegisterAllocator (распределение регистров)
  ↓
Генерация инструкций ассемблера
  ↓
Файл FASM ассемблера
\end{lstlisting}

\subsection{Статус реализации}

\subsubsection{✅ Реализовано}

\begin{itemize}
    \item \textbf{Выражения}:
    \begin{itemize}
        \item Литералы
        \item Идентификаторы/переменные
        \item Бинарные операции (add, sub, and, or, xor, shl, shr)
        \item Унарные операции (not, logical not, unary minus)
        \item Операции сравнения (==, !=, <, <=, >, >=)
        \item Логические операции (\&\&, ||, !)
    \end{itemize}
    
    \item \textbf{Операторы}:
    \begin{itemize}
        \item Объявления переменных
        \item Присваивания
        \item Операторы return
        \item Блоки
    \end{itemize}
    
    \item \textbf{Аппаратные функции}:
    \begin{itemize}
        \item GPIO (gpio\_set, gpio\_read, gpio\_write)
        \item UART (uart\_set\_baud, uart\_read, uart\_write)
    \end{itemize}
    
    \item \textbf{Функции}:
    \begin{itemize}
        \item Определения функций
        \item Вызовы функций (упрощённые)
    \end{itemize}
\end{itemize}

\subsection{Пример сгенерированного кода}

\subsubsection{Простое сложение}

\textbf{Исходный код} (\texttt{add.sc}):
\begin{lstlisting}
function main() {
    uint32 a = 5;
    uint32 b = 3;
    uint32 c = a + b;
    return c;
}
\end{lstlisting}

\textbf{Сгенерированный ассемблер} (\texttt{add.asm}):
\begin{lstlisting}[language={},basicstyle=\ttfamily\small]
include "../../int_pack/ISA.inc"

func_main:
	; Function: main
	mov r11, 5
	mov r12, 3
	add r0, r11, r12
	mov r13, r0
	mov r0, r13
	hlt
\end{lstlisting}

\newpage

\section{Руководство по разработке}

\subsection{Настройка разработки}

\begin{enumerate}
    \item Клонировать репозиторий
    \item Убедиться, что установлен Python 3.7+
    \item Дополнительные зависимости не требуются
\end{enumerate}

\subsection{Запуск тестов}

\begin{lstlisting}[language=bash]
# Запуск всех тестов
python run_tests.py

# Запуск конкретного набора тестов
python -m unittest test_lexer
python -m unittest test_parser
python -m unittest test_interpreter
python -m unittest test_preprocessor
\end{lstlisting}

\subsection{Стиль кода}

\begin{itemize}
    \item Следовать руководящим принципам стиля PEP 8
    \item Использовать подсказки типов, где уместно
    \item Добавлять строки документации ко всем классам и публичным методам
    \item Держать функции сфокусированными и небольшими
    \item Добавлять комментарии для сложной логики
\end{itemize}

\subsection{Добавление новых функций}

\subsubsection{Добавление нового оператора}

\begin{enumerate}
    \item \textbf{Лексер} (\texttt{lexer.py}):
    \begin{itemize}
        \item Добавить тип токена в перечисление \texttt{TokenType}
        \item Добавить распознавание в метод \texttt{tokenize()}
        \item Обеспечить правильный приоритет (многознаковые операторы сначала)
    \end{itemize}
    
    \item \textbf{Парсер} (\texttt{parser.py}):
    \begin{itemize}
        \item Добавить метод парсинга, если нужен для приоритета
        \item Интегрировать в иерархию парсинга выражений
        \item Обновить таблицу приоритета операторов
    \end{itemize}
    
    \item \textbf{Интерпретатор} (\texttt{interpreter.py}):
    \begin{itemize}
        \item Добавить вычисление в \texttt{evaluate\_binary\_op()} или \texttt{evaluate\_unary\_op()}
        \item Обработать граничные случаи (переполнение, деление на ноль и т.д.)
    \end{itemize}
    
    \item \textbf{Тесты}:
    \begin{itemize}
        \item Добавить тестовые случаи в соответствующий файл тестов
        \item Тестировать обычные случаи, граничные случаи и случаи ошибок
    \end{itemize}
    
    \item \textbf{Документация}:
    \begin{itemize}
        \item Обновить \texttt{LANGUAGE\_SPEC.md}
        \item Обновить \texttt{README.md}, если это основная функция
    \end{itemize}
\end{enumerate}

\newpage

\section{Структура проекта}

\subsection{Корневая директория}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
aiproj/
├── Основные файлы реализации (корень)
│   ├── main.py              # Главная точка входа
│   ├── lexer.py             # Токенизатор (исходный код → токены)
│   ├── parser.py            # Парсер (токены → AST)
│   ├── interpreter.py       # Интерпретатор (AST → выполнение)
│   ├── preprocessor.py      # Препроцессор (обработка #include)
│   ├── codegen.py           # Генератор кода (AST → ассемблер)
│   └── compile.py           # Скрипт компиляции
│
├── Документация
│   ├── README.md            # Основная документация проекта (корень)
│   └── doc/                 # Директория документации
│       ├── LANGUAGE_SPEC.md     # Полная спецификация языка
│       ├── ARCHITECTURE.md       # Обзор архитектуры системы
│       ├── INCLUDE_MECHANISM.md  # Детали директивы #include
│       ├── CONTRIBUTING.md       # Руководство по разработке
│       ├── CODE_GENERATION.md   # Детали генерации кода
│       └── PROJECT_STRUCTURE.md  # Этот файл
│
├── Примеры
│   ├── examples/
│   │   ├── basic/           # Базовые примеры программирования
│   │   │   └── hello_world/ # Пример Hello World
│   │   ├── hardware/        # Примеры работы с железом/MCU
│   │   ├── operators/       # Примеры тестирования операторов
│   │   ├── includes/        # Примеры директив включения
│   │   ├── advanced/        # Продвинутые примеры программирования
│   │   └── README.md        # Документация примеров
│   └── user_examples/       # Примеры пользовательских программ
│       ├── simple_return/   # Простой пример возврата
│       ├── complex_example/ # Сложный пример с функциями
│       └── test_example/    # Тестовый пример
│
├── Тесты
│   └── self_tests/          # Директория модульных тестов
│       ├── test_lexer.py        # Модульные тесты лексера
│       ├── test_parser.py       # Модульные тесты парсера
│       ├── test_interpreter.py  # Модульные тесты интерпретатора
│       ├── test_preprocessor.py # Модульные тесты препроцессора
│       └── run_tests.py        # Скрипт запуска тестов
│
└── int_pack/                # Инструменты FASM и включения
    ├── FASM.EXE             # Ассемблер FASM
    ├── interpreter_x64.exe  # Интерпретатор бинарных файлов
    ├── ISA.inc              # Определения ISA
    ├── macros.inc           # Макросы FASM
    └── ...
\end{lstlisting}

\subsection{Ограничения}

\begin{itemize}
    \item Нет массивов или указателей
    \item Нет строк или символов
    \item Нет чисел с плавающей точкой
    \item Только один тип данных (uint32)
    \item Деление на ноль вызывает ошибку времени выполнения
    \item Переполнение целых чисел зацикливается (по модулю $2^{32}$)
    \item Нет поддержки макросов \texttt{\#define} (поддерживается только \texttt{\#include})
\end{itemize}

\newpage

\section{Тестирование}

Проект включает комплексные модульные тесты для всех компонентов. Запуск всех тестов:

\begin{lstlisting}[language=bash]
python self_tests/run_tests.py
\end{lstlisting}

Или запуск отдельных файлов тестов:

\begin{lstlisting}[language=bash]
python -m unittest self_tests.test_lexer
python -m unittest self_tests.test_parser
python -m unittest self_tests.test_interpreter
python -m unittest self_tests.test_preprocessor
\end{lstlisting}

\subsection{Покрытие тестами}

\begin{itemize}
    \item \textbf{Тесты лексера} (\texttt{test\_lexer.py}): распознавание токенов, обработка комментариев, пробелы, операторы, случаи ошибок, отслеживание строк/столбцов
    \item \textbf{Тесты парсера} (\texttt{test\_parser.py}): определения функций, объявления переменных, все типы операторов, парсинг выражений, вложенные структуры, случаи ошибок
    \item \textbf{Тесты интерпретатора} (\texttt{test\_interpreter.py}): арифметические операции, область видимости переменных, вызовы функций, управление потоком, инкремент/декремент, граничные случаи (переполнение, деление на ноль, неопределённые переменные/функции)
    \item \textbf{Тесты препроцессора} (\texttt{test\_preprocessor.py}): обработка директив включения, вложенные включения, обнаружение циклических включений, разрешение путей
\end{itemize}

Все тесты используют встроенный фреймворк \texttt{unittest} Python --- внешние зависимости не требуются.

\newpage

\section{Инструкции по компиляции в PDF}

\subsection{Онлайн-компиляция LaTeX в PDF}

Этот документ может быть скомпилирован в PDF с помощью различных онлайн-сервисов. Ниже приведены популярные варианты:

\subsection{Вариант 1: Overleaf (рекомендуется)}

Overleaf --- самый популярный онлайн-редактор LaTeX.

\begin{enumerate}
    \item Перейдите на \url{https://www.overleaf.com/}
    \item Создайте бесплатный аккаунт (если у вас его ещё нет)
    \item Нажмите "New Project" → "Upload Project"
    \item Загрузите файл \texttt{documentation.tex}
    \item Overleaf автоматически скомпилирует документ
    \item Нажмите "Download PDF" для получения готового PDF-файла
\end{enumerate}

\textbf{Преимущества}:
\begin{itemize}
    \item Не требует установки
    \item Автоматическая компиляция при изменениях
    \item Поддержка совместной работы
    \item Большой выбор шаблонов
\end{itemize}

\subsection{Вариант 2: LaTeX Base}

Альтернативный онлайн-редактор LaTeX.

\begin{enumerate}
    \item Перейдите на \url{https://latexbase.com/}
    \item Вставьте содержимое файла \texttt{documentation.tex} в редактор
    \item Нажмите "Compile PDF"
    \item Скачайте готовый PDF-файл
\end{enumerate}

\textbf{Преимущества}:
\begin{itemize}
    \item Простой интерфейс
    \item Не требует регистрации
    \item Быстрая компиляция
\end{itemize}

\subsection{Вариант 3: ShareLaTeX (сейчас часть Overleaf)}

ShareLaTeX был объединён с Overleaf, используйте Overleaf (см. Вариант 1).

\subsection{Вариант 4: Papeeria}

Ещё один онлайн-редактор LaTeX.

\begin{enumerate}
    \item Перейдите на \url{https://papeeria.com/}
    \item Создайте проект
    \item Загрузите или вставьте содержимое \texttt{documentation.tex}
    \item Нажмите "Compile"
    \item Скачайте PDF
\end{enumerate}

\subsection{Вариант 5: CoCalc}

Облачная платформа для вычислений с поддержкой LaTeX.

\begin{enumerate}
    \item Перейдите на \url{https://cocalc.com/}
    \item Создайте проект
    \item Загрузите файл \texttt{documentation.tex}
    \item Откройте файл и используйте встроенный компилятор LaTeX
\end{enumerate}

\subsection{Вариант 6: Compile Latex Online}

Простейший инструмент для быстрой компиляции.

\begin{enumerate}
    \item Перейдите на \url{https://www.compilelatex.com/}
    \item Загрузите файл \texttt{documentation.tex}
    \item Выберите компилятор (pdflatex рекомендуется)
    \item Нажмите "Compile"
    \item Скачайте PDF
\end{enumerate}

\subsection{Локальная компиляция (для справки)}

Если вы предпочитаете компилировать локально:

\begin{lstlisting}[language=bash]
# Установка TeX Live (Linux/Windows) или MacTeX (macOS)

# Компиляция документа
pdflatex documentation.tex
pdflatex documentation.tex  # Повторная компиляция для правильных ссылок

# Или с bibtex (если используете библиографию)
pdflatex documentation.tex
bibtex documentation
pdflatex documentation.tex
pdflatex documentation.tex
\end{lstlisting}

\subsection{Примечания по компиляции}

\begin{itemize}
    \item Этот документ использует пакет \texttt{babel} с опциями \texttt{russian} и \texttt{english}. Убедитесь, что выбранный сервис поддерживает русский язык.
    \item Документ требует пакета \texttt{T2A} для правильного отображения кириллицы.
    \item Если возникают проблемы с компиляцией, попробуйте сервисы, которые явно поддерживают русский язык (например, Overleaf).
    \item При первом запуске компиляция может занять больше времени из-за загрузки необходимых пакетов.
\end{itemize}

\subsection{Рекомендация}

Для этого документа рекомендуется использовать \textbf{Overleaf}, так как он:
\begin{itemize}
    \item Надёжно поддерживает русский язык
    \item Имеет все необходимые пакеты
    \item Предоставляет хорошую документацию
    \item Позволяет легко делиться и редактировать документ
\end{itemize}

\vspace{1cm}

\begin{center}
\textit{Документ создан автоматически на основе документации проекта Simple C-Style Language}
\end{center}

\end{document}
